# Copyright 2024 Katharina Ceesay-Seitz, ETH Zurich.
# Licensed under the General Public License, Version 3.0, see LICENSE for details.
# SPDX-License-Identifier: GPL-3.0-only

import sys
from pathlib import Path
import argparse

sys.path.insert(0, str(Path(__file__).parents[1]))

from common.util_hier_paths import *
from riscv_isa_spec_parser import *
from riscv_isa_scalar_crypto_spec_parser import parse_isa_scalar_crypto, parse_isa_scalar_crypto_listing, get_isa_scalar_crypto_listing_uncompressed, gen_isa_scalar_crypto_instr_def_sva_functions

def gen_checker(insn_type, insn, checker_name, start_cond_prefix, stop_cond_prefix):
  """Generates one checker per operand of the instruction"""

  nr_ops = get_nr_operands(insn_type)
  if nr_ops < 0:
    print(f"Warning: Could not determine number of operands of instruction {insn}")

  s = ""
  for i in range(nr_ops):
    nr = i + 1
    s += f"{checker_name} chk_{checker_name}_{insn}_op{nr}({start_cond_prefix}_{insn}_op{nr}, {stop_cond_prefix}_{insn}_op{nr}, op{nr}_{insn}_t0);\n"

  return s

def write_all_checker_inst(isa, isa_selection, checker_name, checker_inst_file, start_cond_prefix, stop_cond_prefix):
  s = f"// Generated by {Path(__file__).name}\n"

  for insn_name in isa_selection:
    if not insn_name in isa["instructions"]:
      print(f"WARNING: Did not find {insn_name} in ISA spec")
    else:
      s += gen_checker(isa["instructions"][insn_name]["type"], insn_name, checker_name, start_cond_prefix, stop_cond_prefix)

  with open(checker_inst_file, "w") as f:
    f.write(s)

def write_all_start_cond(isa, isa_selection, start_cond_file, start_cond_prefix="taint_start_cond", start_cond_suffix="instr"):
  s = f"// Generated by {Path(__file__).name}\n"

  for insn_name in isa_selection:
    if not insn_name in isa["instructions"]:
      print(f"WARNING: Did not find {insn_name} in ISA spec")
    else:
      nr_ops = get_nr_operands(isa["instructions"][insn_name]["type"])
      if nr_ops < 0:
        print(f"Warning: Could not determine number of operands of instruction {insn_name}")

      for i in range(nr_ops):
        nr = i + 1
        s += f"bit {start_cond_prefix}_{insn_name}_op{nr};\n"
        s += f"assign {start_cond_prefix}_{insn_name}_op{nr} = {start_cond_prefix}_{start_cond_suffix} && {insn_name}();\n\n"

  with open(start_cond_file, "w") as f:
    f.write(s)

def write_all_stop_cond(isa, isa_selection, start_cond_file, stop_cond_prefix="taint_stop_cond"):
  """Example: assign taint_stop_cond_BGEU_op1 = taint_stop_cond_instr && $past(taint_active_BGEU_op1);"""

  s = f"// Generated by {Path(__file__).name}\n"

  for insn_name in isa_selection:
    if not insn_name in isa["instructions"]:
      print(f"WARNING: Did not find {insn_name} in ISA spec")
    else:
      nr_ops = get_nr_operands(isa["instructions"][insn_name]["type"])
      if nr_ops < 0:
        print(f"Warning: Could not determine number of operands of instruction {insn_name}")

      for i in range(nr_ops):
        nr = i + 1
        s += f"bit {stop_cond_prefix}_{insn_name}_op{nr};\n"
        s += f"assign {stop_cond_prefix}_{insn_name}_op{nr} = {stop_cond_prefix}_instr;\n\n"

  with open(start_cond_file, "w") as f:
    f.write(s)

def write_all_operand_assignment_templates(isa, isa_selection, operand_assignment_file, operand_name="operand_placeholder_unconnected_t0", bit_width=32):
  s = f"// Generated by {Path(__file__).name}\n"
  s += f"bit {operand_name};\n\n"

  for insn_name in isa_selection:
    if not insn_name in isa["instructions"]:
      print(f"WARNING: Did not find {insn_name} in ISA spec")
    else:
      nr_ops = get_nr_operands(isa["instructions"][insn_name]["type"])
      if nr_ops < 0:
        print(f"Warning: Could not determine number of operands of instruction {insn_name}")

      for i in range(nr_ops):
        nr = i + 1
        s += f"bit[{bit_width-1}:0] op{nr}_{insn_name}_t0;\n"
        s += f"assign op{nr}_{insn_name}_t0 = {operand_name};\n\n"

  with open(operand_assignment_file, "w") as f:
    f.write(s)


def write_all_debug_insn_sigs(isa, isa_selection, debug_insn_sigs_file):
  s = f"// Generated by {Path(__file__).name}\n"

  for insn_name in isa_selection:
    if not insn_name in isa["instructions"]:
      print(f"WARNING: Did not find {insn_name} in ISA spec")
    else:
      s += f"bit is_{insn_name};\n"
      s += f"assign is_{insn_name} = {insn_name}();\n\n"

  with open(debug_insn_sigs_file, "w") as f:
    f.write(s)

def write_task_creations(isa, isa_selection, operand_stopat_mapping, task_creation_proc, task_name_prefix, checker_name, task_creation_file, start_cond_prefix):
  """create_ucfi_task {taskname checkername instr_taint_base top propertyLocation operand_sig declassify iuv_type }"""

  s = f"# Generated by {Path(__file__).name}\n"

  for insn_name in isa_selection:
    if not insn_name in isa["instructions"]:
      print(f"WARNING: Did not find {insn_name} in ISA spec " + isa_selection )
    else:
      nr_ops = get_nr_operands(isa["instructions"][insn_name]["type"])
      if nr_ops < 0:
        print(f"Warning: Could not determine number of operands of instruction {insn_name}")

      for i in range(nr_ops):
        nr = i + 1

        operand_stopat_name = operand_stopat_mapping[f"op{nr}_{insn_name}_t0"]
        if operand_stopat_name == "operand_placeholder_unconnected_t0":
          operand_stopat_name = ""
        operand_stopat_name = "{" + operand_stopat_name + "}"

        s += f'{task_creation_proc} "{task_name_prefix}_{insn_name}_op{nr}" "chk_{checker_name}_{insn_name}_op{nr}" ' \
             f'"instr_taint_base" $top $propertyLocation {operand_stopat_name} 1 {insn_name}\n'

  task_creation_file.parent.mkdir(parents=True, exist_ok=True)
  with open(task_creation_file, "w") as f:
    f.write(s)



def generate_operand_dv_signal_mapping(operand_assignments_file):
  operand_dv_signal = {}
  with open(operand_assignments_file, "r") as f:
    for line in f:
      if "=" in line:
        operand_name = line.split("=")[0].strip().split(" ")[-1].strip()
        signal_name = line.split("=")[1].strip().replace(";","").strip()
        operand_dv_signal[operand_name] = signal_name
  return operand_dv_signal

def generate_dv_hier_signal_mapping_from_bind(bind_file):
  """Generates a mapping from SV signal names to hierarchical names in the DUT"""
  operand_mapping = {}
  with open(bind_file, "r") as f:
    s = f.read()
    matches = re.findall(r"\.(.*?)\((.*?)\)", s, re.DOTALL)
    for m in matches:
      operand_mapping[m[0].strip()] = m[1].strip()
  return operand_mapping

def generate_operand_stopat_mapping(operand_assignments_file, bind_file):
  dv_hier_signal_mapping = generate_dv_hier_signal_mapping_from_bind(bind_file)
  operand_dv_signal_mapping = generate_operand_dv_signal_mapping(operand_assignments_file)
  operand_stopat_mapping = {}
  for operand_name, dv_signal_name in operand_dv_signal_mapping.items():
    if dv_signal_name in dv_hier_signal_mapping:
      operand_stopat_mapping[operand_name] = dv_hier_signal_mapping[dv_signal_name]
    else:
      operand_stopat_mapping[operand_name] = "operand_placeholder_unconnected_t0"
  return operand_stopat_mapping


def write_all_signal_definitions(isa, isa_selection,  start_cond_file, stop_cond_file,
                            operand_assignments_file, debug_insn_sigs_file):

  write_all_start_cond(isa, isa_selection, start_cond_file)
  write_all_stop_cond(isa, isa_selection, stop_cond_file)
  write_all_operand_assignment_templates(isa, isa_selection, operand_assignments_file)

  write_all_debug_insn_sigs(isa, isa_selection, debug_insn_sigs_file)

def write_all_pc_taint_checks(isa, isa_selection, operand_stopat_mapping, checker_name, task_creation_file):

  # write_task_creations(isa, isa_selection, operand_stopat_mapping, "create_task_compare_taint_start_time", "t_compare_taint_start_time",
  #   checker_name, task_creation_file, "taint_start_cond")
  write_task_creations(isa, isa_selection, operand_stopat_mapping, "create_ucfi_task", f"t_compare_taint_start_time_{checker_name}",
    checker_name, task_creation_file, "taint_start_cond")
  # #

def write_common_files(isa, isa_selection, checker_names, out_dir_in, file_prefix=""):
  out_dir = Path(out_dir_in)
  out_dir.mkdir(parents=True, exist_ok=True)

  for checker_name in checker_names:
    start_cond_file = out_dir / f"{file_prefix}start_cond_{checker_name}.sv"
    stop_cond_file = out_dir / f"{file_prefix}stop_cond_{checker_name}.sv"

    operand_assignments_file = out_dir / "signal_defs" / f"{file_prefix}operand_assignments.sv"
    operand_assignments_file.parent.mkdir(parents=True, exist_ok=True)

    checker_inst_file = out_dir / f"{file_prefix}checker_inst_{checker_name}.sv"

    debug_insn_file = out_dir / f"{file_prefix}debug_insn_sigs.sv"

    write_all_signal_definitions(isa, isa_selection, start_cond_file, stop_cond_file,
                              operand_assignments_file, debug_insn_file)

    write_all_checker_inst(isa, isa_selection, checker_name, checker_inst_file, "taint_start_cond", "taint_stop_cond")

def write_core_specific_files(isa, isa_selection, checker_names, operand_assignments_file_completed, bind_file, task_creation_dir):

  for checker_name in checker_names:
    operand_stopat_mapping = generate_operand_stopat_mapping(operand_assignments_file_completed, bind_file)
    write_all_pc_taint_checks(isa, isa_selection, operand_stopat_mapping, checker_name, task_creation_dir / f"task_creations_{checker_name}.tcl")

if __name__ == "__main__":

  parser = argparse.ArgumentParser(description='Generates setup for a new core for formal verification')
  parser.add_argument('--operand_assignments_file', dest='operand_assignments_file', type=str, required=False, help='The completed operand assignments file')
  parser.add_argument('--bind_file', dest='bind_file', type=str, required=False, help='The generated bind file')
  parser.add_argument('--task_creation_dir', dest='task_creation_dir', type=str, required=False, help='The output directory where task creations should be written to.')
  parser.add_argument('--isa_selection', dest='isa_selection_str', type=str, required=False, help='A comma separated list of isa extensions to use. Example: "i,zifencei,zicsr,m"')
  parser.add_argument('--gen_all_common_files', dest='gen_all_common_files', type=bool, required=False, help='Generates all common files for the selected isa extensions. out_dir must be set as the output dir.')
  parser.add_argument('--out_dir', dest='out_dir', type=str, required=False, help='Output directory for the common files')
  parser.add_argument('--common_file_prefix', dest='common_file_prefix', type=str, required=False, help='Filename prefix for the genrated common files')
  parser.add_argument('--gen_isa_sva_functions', dest='gen_isa_sva_functions', type=str, required=False, help='Generate the selected isa function definitions for SVA. out_dir must be set as the output dir. Supported only for crypto')

  args = parser.parse_args()

  if (args.gen_all_common_files and args.out_dir is None):
    raise Exception("Must set out_dir if gen_all_common_files is selected.")

  rv_extensions = args.isa_selection_str.split(",")

  isa, isa_selection = get_isa_spec_and_listing(rv_extensions)
  #print(isa)
  print(isa_selection)

  checker_names = ["pc_taint_checker_to_anytime",
                    "pc_taint_checker_to_anytime_no_taint_states"]

  if args.gen_all_common_files:
    write_common_files(isa, isa_selection, checker_names, args.out_dir, args.common_file_prefix)

  ###### To generate the crypto function definitions for SVA:
  elif args.gen_isa_sva_functions and "crypto" in args.isa_selection_str and args.out_dir is not None:
    p_out_dir = Path(args.out_dir)
    p_out_dir.mkdir(parents=True, exist_ok=True)
    gen_isa_scalar_crypto_instr_def_sva_functions(crypto_spec_instr_root, Path(__file__).parents[0] / p_out_dir / "crypto_func_defs.sv")

  else:
    if not args.bind_file or not args.task_creation_dir or not args.operand_assignments_file:
      raise Exception("Must set bind_file, task_creation_file and operand_assignments_file if not generating all common files.")
    Path(args.task_creation_dir).mkdir(parents=True, exist_ok=True)
    write_core_specific_files(isa, isa_selection, checker_names, args.operand_assignments_file, Path(args.bind_file), Path(args.task_creation_dir))



