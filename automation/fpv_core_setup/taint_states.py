# Copyright 2024 Katharina Ceesay-Seitz, ETH Zurich.
# Licensed under the General Public License, Version 3.0, see LICENSE for details.
# SPDX-License-Identifier: GPL-3.0-only

import sys
from pathlib import Path
import re

sys.path.insert(0, str(Path(__file__).parents[1]))

from common.util import *
from common.util_hier_paths import *

def print_line(file_lines, i):
    line = file_lines[i].rstrip('\n')
    print(f"{i}: {line}")

def extract_write_verilog_meta_info(line, i, searchstr, file_lines_dbg):
    if not searchstr in line:
        print(f"WARNING: Found taint state without {searchstr} information. file_lines:")
        print_line(file_lines_dbg, i-1)
        print_line(file_lines_dbg, i)
        print_line(file_lines_dbg, i+1)
        return ""

    s = line.strip()
    s = s.replace(f"/* {searchstr} ", "")
    s = s.replace(" */", "")
    return s

def extract_taint_states(design_file):
    taint_attributes = ["taint_ff", "taint_latch"]
    taint_states = {}
    with open(design_file, "r") as f:
        file_lines = f.readlines()
        i = 0
        while i < len(file_lines):
            line = file_lines[i]

            taint_state_found = False
            # find taint attribute
            for taint_attr in taint_attributes:
                if f"/* {taint_attr} = 32'd1 */" in line:
                    taint_state_found = True
                    break
            if taint_state_found:
                assert i + 3 < len(file_lines), "Found a taint state, expecting at least 3 more file_lines."
                # extract module name
                i += 1
                line = file_lines[i]
                searchstr = "PC_TAINT_INFO MODULE_NAME"
                module_name = extract_write_verilog_meta_info(line, i, searchstr, file_lines).strip()

                # extract register name
                i += 1
                line = file_lines[i]
                searchstr = "PC_TAINT_INFO STATE_NAME"
                state_name = trim_size_marker(extract_write_verilog_meta_info(line, i, searchstr, file_lines)).strip()

                if not module_name in taint_states:
                    taint_states[module_name] = list()
                taint_states[module_name].append(state_name)
            i+=1
    return taint_states

def get_taint_states_as_jasper_paths(design_data, path_to_core, statefile, design_file, top_module, tcl_paths_without_top_module=True):
    """
    This function needs Jasper.
    To find all taint states this function prints a list of states with full hierarchical paths using Jasper.
    It then checks in the Yosys output whether it's a taint signal. We've let Yosys print the information into the module definitions.
    Using Jasper to print the hierarchical paths saves us from searching through the design hierarchy and finding all instantiations of the module.
    Would be the cleaner solution though.
    """
    run_cmd(f"make -C {path_to_core} run_cmd CONFIG=print_taint_states DESIGN_FILE={design_file}")

    taint_states_with_paths = list()
    with open(Path(path_to_core, statefile), "r") as f:
        states = f.read() # from Jasper
        taint_states = extract_taint_states(design_file) # from Yosys attributes added to design

        for state in jasper_tcl_sig_list_split(states):
            if tcl_paths_without_top_module:
                state_with_top = jasper_tcl_sig_add_top_module(top_module, state)
            else:
                state_with_top = state
            state_mod = get_module_type(design_data, jasper_tcl_get_split_path_of_instance(state_with_top))
            print(taint_states.keys())
            if state_mod in taint_states.keys() and jasper_tcl_sig_extract_sig_name(state) in taint_states[state_mod]:
                taint_states_with_paths.append(state)
    return taint_states_with_paths


def gen_symb_init_taint_states_asms(taint_states_with_paths, outfile):
    s = f"# Generated by {__file__}\n"
    s += "proc no_taint_in_symb_init {taskName} {\n\n"

    for state in taint_states_with_paths:
        s += "assume -task $taskName -bound 1 {" + state + " == 0 }\n"
    s += "}"
    with open(outfile, "w") as f:
        f.write(s)
    print(f"Taint assumptions generated in {outfile}")

def gen_taint_propagation_checker(taint_states_with_paths, outfile, prop_prefix = "c_taint_propagation_"):
    """
    TODO: Checker accesses taint states with yosys generated names. They are not yet automatically added to the bind file
    """
    s = f"// Generated by {__file__}\n"
    s += "checker pc_taint_find_taint_propagation_bounded(untyped bound);\n\n"

    for state in taint_states_with_paths:
        state_formal_name = flatten_signal_path(remove_curley_brackets(state))
        s += "  " + prop_prefix + state_formal_name + ": cover property(##bound " + state_formal_name + ");\n"
    s += "endchecker"
    with open(outfile, "w") as f:
        f.write(s)

def gen_no_taint_ever_props(taint_states_with_paths, outfile, prop_prefix = "as_no_taint_ever_"):
    """
    TODO: Checker accesses taint states with yosys generated names. They are not yet automatically added to the bind file
    """
    s = f"// Generated by {__file__}\n"
    s += "checker chk_no_taint_ever();\n\n"

    for state in taint_states_with_paths:
        state_formal_name = flatten_signal_path(remove_curley_brackets(state))
        s += "  " + prop_prefix + state_formal_name + ": assert property(!" + state_formal_name + ");\n"
    s += "endchecker"
    with open(outfile, "w") as f:
        f.write(s)
