# ùúáCFI Formal Verification

## Execution

### Run

Run all commands / launch the verification tool in the directory of the processor that you want to verify.

Enter a processor's directory and run "make help" to print usage information.

### Restore a session

What can be restored:
- A cmd session where proofs were already started:
A session running in the command line may be stopped with ctrl+C, once the proofs have been started. Before that, the data base is not yet saved.
Once a session is running proofs, it can be stopped with ONE ctrl+C command. Sending it multiple times, will stop the session's cleanup.
- A GUI session.
The GUI window may be closed without stopping the run.

A session can not be captured while it is running. An attempt may currupt the database.

Make targets to restore: see common/common.mk help (or type 'make help')

### Printing reports

By default the setup prints reports regularly, and once when all properties are proven. Run 'make help' to list available options.


### Configurations

Tool configuration can be found in common/formal/scripts/launchers/jasper_config.tcl

## Development

CPU specific files are stored in verification/<design_dir>. The main property file in verification/<design_dir>/formal/properties/<CPU_name>_ct_instr_all.sv ([example](picorv32_ift_pregenerated/formal/properties/picorv32_ct_instr_all.sv)) includes all common files (found in verification/common/formal) and instantiates/connects them with CPU specific signals and the generated taint conditions in verification/<design_dir>/formal/properties/taint_conditions.
The configuration that is loaded by the Makefile of a core, e.g. [here](picorv32_ift_pregenerated/configurations/picorv32_ct_to.mk). Many of the following files could be exchanged by adapting the paths here. The TASK_FILE (here is the [default task script](common/formal/scripts/tasks/ct_instr_all_no_taint_states.tcl)) includes the checkers and runs the proofs.

The common main property file is [here](common/formal/properties/prop_ct_instr.sv).

The ùúáCFI property is defined [here](common/formal/properties/prop_pc_taint_check.sv).

It is used by the SystemVerilog Checkers [here](common/formal/assumptions/asm_taint_inj_once.sv), which also define the taint injection assumptions. These checkers are instantiated per CPU by passing taint conditions and the instruction operand as operand source to them.

The checkers are instantiated per instruction and operand in a separate task.
Task creation per instruction for a specific core are e.g. [here](picorv32_ift_pregenerated/formal/scripts/tasks/task_creations_pc_taint_checker_to_anytime_no_taint_states.tcl).
This file is generated by a [Python script](../automation/mucfi/gen_checker_inst.py).
They call the main task creation [script](common/formal/scripts/tasks/task_creations.tcl).

The first script that is loaded by Jasper is [here](common/formal/scripts/launchers/verif_cadence.tcl).

Operand definitions for a specific core are e.g. [here](picorv32_ift_pregenerated/formal/signal_defs/operand_assignments_first.sv)


## Setup for a new core

### CellIFT-ing the design

See the main [README](../README.md)

### Core setup

#### Automated:
Run 'make setup_design', see the main [Makefile](../Makefile)

#### Manually:

2. Optional: rename the top module to a nice verbose name (it's used everywhere).
3. Create the design directory following the structure in e.g., verification/kronos_dft_pregenerated
4. Generate basic formal setup. Example for kronos:
  python cellift-formal/py_scripts/fpv_core_setup/fpv_core_setup.py --design_file <designfile.sv> --top_module kronos_core --outdir kronos --gen_bind_and_mod=True --regen_design_hier=True --gen_reset_seq=True --gen_input_no_taint_asm=True --target_tool=jasper
5. Copy verification/kronos_dft_pregenerated/configurations/print_taint_states.mk. Adapt to the new core. Create all files (can be empty)
6. Copy and adapt the Makefile

---
7. In the core's directory (e.g. ./kronos, relative to this README), call "make run CONFIG=print_taint_states DESIGN_FILE=<relative_path_to_design>". Example for <relative_path_to_design>: in ./kronos: "designs/design_name.sv"
8. Generate taint state related properties, symbolic initial state assumptions and an updated bind and module file:
python fpv_core_setup.py --design_file generated/cellift_kronos_9e4fa466.sv --top_module cellift_kronos --outdir kronos --gen_symb_init=True --gen_taint_propagation_checker=True --target_tool=jasper --path_to_core=generated --gen_bind_and_mod=True
9. Copy the updated bind and module file to the core's directory
----

10. Copy a configuration from an other core.
11. Generate task creation files with correct signal names with pc_taint_check/gen_checker_inst.py. The checker instantiations are in the common directory.
12. Copy formal/properties/cellift_<core>_ct_instr.sv from an existing core and adapt to the new core. This one is later on supposed to be filled automatically with the generated taint conditions.
13. Copy signal_defs/operand_assignments_first.sv from any existing core and adapt. This one is supposed to be generated later based on the signals found in the waveforms.

If the design file changes, repeat steps 4, 7-9.

If you write your own checkers, you can adapt gen_checker_inst.py to generate new kind of checker instantiations.